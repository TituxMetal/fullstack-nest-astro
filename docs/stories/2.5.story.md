---
epic: '2'
story_id: '2.5'
title: 'Infrastructure Foundation - Repository Patterns and Database Abstraction'
status: 'Approved'
priority: 'CRITICAL'
as_a: 'developer working with any data access layer'
i_want: 'a standardized repository abstraction layer with base interfaces and common patterns'
so_that:
  'all modules can use consistent data access patterns while maintaining Clean Architecture
  separation and enabling future database changes'
acceptance_criteria:
  # Shared Infrastructure Foundation
  - 'AC2.5.1: Move Prisma infrastructure to shared/infrastructure/database/ (PrismaService,
    PrismaModule), create shared/infrastructure/database/Database.module.ts that exports
    PrismaService, and update all existing imports to use shared location'
  # Base Repository Interface
  - 'AC2.5.2: Create shared/domain/repositories/BaseRepository.interface.ts with generic
    IRepository<TEntity, TId> interface containing standard CRUD operations: findById, findAll,
    save, update, delete, exists methods with proper typing'
  # Base Repository Implementation
  - 'AC2.5.3: Create shared/infrastructure/repositories/BaseRepository.abstract.ts with abstract
    BaseRepository<TEntity, TId, TPersistence> class implementing common CRUD operations using
    Prisma, with abstract methods for mapping (mapToDomain, mapToPersistence)'
  # Unit of Work Pattern
  - 'AC2.5.4: Create shared/infrastructure/database/UnitOfWork.service.ts with UnitOfWorkService
    implementing transaction management, batch operations, and commit/rollback functionality using
    Prisma transactions'
  # Repository Factory Pattern
  - 'AC2.5.5: Create shared/infrastructure/repositories/RepositoryFactory.service.ts with
    RepositoryFactoryService for dynamic repository creation and dependency injection management'
  # Migration and Integration
  - 'AC2.5.6: Update existing PrismaAuthUserRepository to extend BaseRepository and verify all auth
    functionality continues to work identically, update imports across codebase to use shared
    infrastructure'
  # Integration Verification
  - 'IV2.5.1: All existing auth endpoints work identically with new repository foundation'
  - 'IV2.5.2: Database operations maintain same performance characteristics'
  - 'IV2.5.3: All existing tests pass with updated imports and base repository'
  - 'IV2.5.4: Transaction management works correctly with unit of work pattern'
  - 'IV2.5.5: Repository factory can create and manage repository instances correctly'
---

## Tasks / Subtasks

- [ ] **Task 1: Move Prisma Infrastructure to Shared Foundation** (AC: 2.5.1)
  - [ ] Create `shared/infrastructure/database/` directory structure
  - [ ] Move `src/prisma/prisma.service.ts` to `shared/infrastructure/database/Prisma.service.ts`
  - [ ] Move `src/prisma/prisma.module.ts` to `shared/infrastructure/database/Prisma.module.ts`
  - [ ] Create `shared/infrastructure/database/Database.module.ts` as main database module export
  - [ ] Create `shared/infrastructure/database/index.ts` barrel file
  - [ ] Update all existing imports across codebase to use new shared location
  - [ ] Remove original `src/prisma/` directory after successful migration
  - [ ] Write integration tests for database module functionality

- [ ] **Task 2: Create Base Repository Interface** (AC: 2.5.2)
  - [ ] Create `shared/domain/repositories/BaseRepository.interface.ts` with
        `export interface IRepository<TEntity, TId>`
  - [ ] Define standard CRUD methods: `findById(id: TId): Promise<TEntity | null>`
  - [ ] Define collection methods: `findAll(options?: FindOptions): Promise<TEntity[]>`
  - [ ] Define mutation methods: `save(entity: TEntity): Promise<TEntity>`,
        `update(id: TId, entity: Partial<TEntity>): Promise<TEntity>`
  - [ ] Define deletion methods: `delete(id: TId): Promise<void>`,
        `exists(id: TId): Promise<boolean>`
  - [ ] Create `FindOptions` interface for query parameters (pagination, sorting, filtering)
  - [ ] Create `shared/domain/repositories/index.ts` barrel file
  - [ ] Write comprehensive unit tests for interface contracts

- [ ] **Task 3: Create Abstract Base Repository Implementation** (AC: 2.5.3)
  - [ ] Create `shared/infrastructure/repositories/BaseRepository.abstract.ts` with
        `export abstract class BaseRepository<TEntity, TId, TPersistence>`
  - [ ] Implement generic CRUD operations using PrismaService injection
  - [ ] Define abstract mapping methods: `abstract mapToDomain(persistence: TPersistence): TEntity`
  - [ ] Define abstract mapping methods: `abstract mapToPersistence(entity: TEntity): TPersistence`
  - [ ] Implement error handling for common database operations
  - [ ] Add logging and monitoring hooks for repository operations
  - [ ] Create `shared/infrastructure/repositories/index.ts` barrel file
  - [ ] Write integration tests for base repository implementation

- [ ] **Task 4: Implement Unit of Work Pattern** (AC: 2.5.4)
  - [ ] Create `shared/infrastructure/database/UnitOfWork.service.ts` with
        `export class UnitOfWorkService`
  - [ ] Implement transaction management using Prisma `$transaction` API
  - [ ] Add batch operation support for multiple repository operations
  - [ ] Implement commit/rollback functionality with proper error handling
  - [ ] Add transaction isolation level configuration
  - [ ] Create transaction context management for nested operations
  - [ ] Write comprehensive tests for transaction scenarios
  - [ ] Add integration with repository base class for automatic transaction support

- [ ] **Task 5: Create Repository Factory Pattern** (AC: 2.5.5)
  - [ ] Create `shared/infrastructure/repositories/RepositoryFactory.service.ts` with
        `export class RepositoryFactoryService`
  - [ ] Implement dynamic repository creation based on entity types
  - [ ] Add repository registration and discovery mechanisms
  - [ ] Implement dependency injection integration for repository instances
  - [ ] Add repository lifecycle management (singleton vs transient)
  - [ ] Create type-safe factory methods for each repository type
  - [ ] Write unit tests for factory functionality
  - [ ] Document factory patterns and usage examples

- [ ] **Task 6: Update Existing Repository Implementation** (AC: 2.5.6)
  - [ ] Refactor `PrismaAuthUserRepository` to extend `BaseRepository<AuthUserEntity, string, User>`
  - [ ] Move common CRUD operations to use base class implementations
  - [ ] Keep auth-specific methods (findByEmail, findByUsername) as overrides
  - [ ] Update repository to use shared Prisma service from new location
  - [ ] Verify all existing auth functionality works identically
  - [ ] Update Auth.module.ts to use shared database module
  - [ ] Run all existing auth tests to ensure no regressions
  - [ ] Update any auth-specific integration tests

- [ ] **Task 7: Update Application-Wide Imports and Configuration** (AC: 2.5.6)
  - [ ] Update `app.module.ts` to import shared Database.module instead of Prisma.module
  - [ ] Search and update all imports of PrismaService to use shared location
  - [ ] Update all imports of PrismaModule to use DatabaseModule
  - [ ] Verify all modules can resolve Prisma dependencies correctly
  - [ ] Update any configuration or environment setup for database access
  - [ ] Clean up old prisma module references in module configuration
  - [ ] Verify build succeeds with all updated imports

- [ ] **Task 8: Integration Verification** (IV: 2.5.1-2.5.5)
  - [ ] Test all existing auth endpoints maintain identical behavior
  - [ ] Verify database operations maintain same performance characteristics
  - [ ] Ensure all existing tests pass with updated repository foundation
  - [ ] Test transaction management works correctly in various scenarios
  - [ ] Verify repository factory can create and manage all repository types
  - [ ] Run full integration test suite to ensure no regressions
  - [ ] Verify database connection and query logging still works properly
  - [ ] Test error handling and recovery scenarios with new foundation

## Dev Notes

### Architectural Foundation Rationale

From Story 2.2 QA review, the following critical architectural debt was identified:

**"Missing repository abstractions (direct Prisma usage)"** and **"Infrastructure concerns leaking
into business logic"**

This Infrastructure Foundation story addresses these core issues by establishing:

1. **Repository Abstraction Layer**: Eliminates direct Prisma dependencies from domain/application
   layers
2. **Shared Infrastructure**: Centralizes database concerns in a shared location accessible to all
   modules
3. **Transaction Management**: Provides proper unit of work pattern for complex business operations
4. **Standardization**: Ensures all future modules use consistent data access patterns

[Source: docs/stories/2.2.story.md#QA Results - Broader Architectural Analysis]

### Clean Architecture Alignment

**Before - Direct Infrastructure Dependency:**

```treeview
auth/infrastructure/repositories/
├── PrismaAuthUser.repository.ts (direct PrismaService dependency)
└── [duplicates Prisma concerns across modules]
```

**After - Proper Abstraction Layer:**

```treeview
shared/
├── domain/repositories/
│   ├── BaseRepository.interface.ts (clean abstraction)
│   └── index.ts
├── infrastructure/
│   ├── database/
│   │   ├── Database.module.ts
│   │   ├── Prisma.service.ts
│   │   ├── UnitOfWork.service.ts
│   │   └── index.ts
│   └── repositories/
│       ├── BaseRepository.abstract.ts
│       ├── RepositoryFactory.service.ts
│       └── index.ts
```

### Repository Pattern Benefits

**Standard CRUD Interface (IRepository<TEntity, TId>):**

- Consistent API across all domain repositories
- Type-safe operations with generic typing
- Standardized error handling and validation
- Easy mocking for unit tests
- Database-agnostic business logic

**Abstract Base Implementation:**

- Eliminates code duplication across repositories
- Enforces mapping patterns (Domain ↔ Persistence)
- Provides common error handling and logging
- Enables consistent transaction management
- Simplifies repository implementation

**Unit of Work Pattern:**

- Manages complex business transactions across multiple entities
- Ensures data consistency with proper rollback capabilities
- Optimizes database performance with batch operations
- Provides clear transaction boundaries for business operations

### Current Infrastructure Analysis

**Existing Prisma Usage:**

- `apps/backend/src/prisma/prisma.service.ts` - Core database connection service
- `apps/backend/src/prisma/prisma.module.ts` - Module configuration
- `apps/backend/src/auth/infrastructure/repositories/PrismaAuthUser.repository.ts` - Direct usage

**Dependencies to Update:**

- `apps/backend/src/app.module.ts` - Import PrismaModule → DatabaseModule
- `apps/backend/src/auth/Auth.module.ts` - Import PrismaModule → DatabaseModule
- Any other modules directly importing PrismaService

### Target Architecture Design

**Shared Infrastructure Foundation:**

```typescript
// Base repository interface - domain layer
export interface IRepository<TEntity, TId> {
  findById(id: TId): Promise<TEntity | null>
  findAll(options?: FindOptions): Promise<TEntity[]>
  save(entity: TEntity): Promise<TEntity>
  update(id: TId, updates: Partial<TEntity>): Promise<TEntity>
  delete(id: TId): Promise<void>
  exists(id: TId): Promise<boolean>
}

// Abstract base implementation - infrastructure layer
export abstract class BaseRepository<TEntity, TId, TPersistence>
  implements IRepository<TEntity, TId>
{
  constructor(protected readonly prisma: PrismaService) {}

  // Implemented CRUD operations using Prisma
  async findById(id: TId): Promise<TEntity | null> {
    // Generic implementation
  }

  // Abstract mapping methods for concrete repositories
  abstract mapToDomain(persistence: TPersistence): TEntity
  abstract mapToPersistence(entity: TEntity): TPersistence
}
```

**Repository Implementation Pattern:**

```typescript
// Concrete repository extends base
export class PrismaAuthUserRepository
  extends BaseRepository<AuthUserEntity, string, User>
  implements IAuthUserRepository
{
  // Domain-specific methods
  async findByEmail(email: EmailValueObject): Promise<AuthUserEntity | null> {
    // Auth-specific implementation
  }

  // Required mapping implementations
  mapToDomain(user: User): AuthUserEntity {
    // Persistence → Domain mapping
  }

  mapToPersistence(entity: AuthUserEntity): User {
    // Domain → Persistence mapping
  }
}
```

### Unit of Work Pattern Design

**Transaction Management:**

```typescript
export class UnitOfWorkService {
  constructor(private readonly prisma: PrismaService) {}

  async execute<T>(operations: (prisma: PrismaClient) => Promise<T>): Promise<T> {
    return this.prisma.$transaction(operations)
  }

  async batch<T>(operations: Promise<T>[]): Promise<T[]> {
    return this.prisma.$transaction(operations)
  }
}
```

**Usage in Business Logic:**

```typescript
// Use case with multiple repository operations
export class RegisterUseCase {
  constructor(
    private readonly authUserRepository: IAuthUserRepository,
    private readonly unitOfWork: UnitOfWorkService
  ) {}

  async execute(dto: RegisterDto): Promise<void> {
    await this.unitOfWork.execute(async prisma => {
      // Multiple operations in single transaction
      await this.authUserRepository.save(authUser)
      // Additional operations...
    })
  }
}
```

### Repository Factory Pattern

**Dynamic Repository Management:**

```typescript
export class RepositoryFactoryService {
  private repositories = new Map<string, IRepository<any, any>>()

  register<TEntity, TId>(name: string, repository: IRepository<TEntity, TId>): void {
    this.repositories.set(name, repository)
  }

  get<TEntity, TId>(name: string): IRepository<TEntity, TId> {
    return this.repositories.get(name) as IRepository<TEntity, TId>
  }
}
```

### Migration Strategy

**Zero-Downtime Approach:**

1. **Create Shared Foundation**: Build new shared infrastructure without touching existing code
2. **Migrate Prisma Infrastructure**: Move existing Prisma services to shared location
3. **Update Imports**: Change all import paths to use shared infrastructure
4. **Refactor Existing Repository**: Update PrismaAuthUserRepository to use base class
5. **Verify Functionality**: Ensure all existing behavior works unchanged
6. **Clean Up**: Remove old infrastructure after verification

**Critical Preservation Requirements:**

- All existing repository methods must work identically
- Database queries must maintain same performance
- Transaction behavior must be preserved
- Error handling patterns must remain consistent
- Test fixtures and mocks must continue working

### File Locations and Path Standards

**New Import Paths:**

- Base Interface: `import { IRepository } from '~/shared/domain/repositories'`
- Base Implementation: `import { BaseRepository } from '~/shared/infrastructure/repositories'`
- Database Services:
  `import { PrismaService, UnitOfWorkService } from '~/shared/infrastructure/database'`
- Repository Factory:
  `import { RepositoryFactoryService } from '~/shared/infrastructure/repositories'`

**Directory Structure After Implementation:**

```treeview
apps/backend/src/
├── shared/
│   ├── domain/
│   │   └── repositories/
│   │       ├── BaseRepository.interface.ts
│   │       └── index.ts
│   └── infrastructure/
│       ├── database/
│       │   ├── Database.module.ts
│       │   ├── Prisma.service.ts
│       │   ├── UnitOfWork.service.ts
│       │   └── index.ts
│       └── repositories/
│           ├── BaseRepository.abstract.ts
│           ├── RepositoryFactory.service.ts
│           └── index.ts
├── auth/
│   └── infrastructure/
│       └── repositories/
│           └── PrismaAuthUser.repository.ts (extends BaseRepository)
└── [no standalone prisma/ directory]
```

### Performance and Scalability Considerations

**Repository Pattern Performance:**

- Base implementation provides optimized query patterns
- Transaction management reduces connection overhead
- Factory pattern enables efficient repository lifecycle management
- Consistent error handling reduces exception overhead

**Database Connection Management:**

- Shared PrismaService ensures single connection pool
- Unit of work pattern optimizes transaction boundaries
- Repository base class provides consistent query patterns
- Factory service manages repository instances efficiently

### Risk Assessment

**Risk Level: LOW-MEDIUM** - Foundation work with existing functionality preservation

**Mitigation Strategies:**

1. **Incremental Implementation**: Build shared foundation before migrating existing code
2. **Comprehensive Testing**: Verify every repository operation maintains identical behavior
3. **Rollback Plan**: Keep existing structure until all tests pass
4. **Performance Monitoring**: Ensure no performance degradation with new abstraction layer

**Dependencies Affected:**

- All modules using PrismaService directly
- Auth module repository implementation
- Any business logic performing database operations
- Test fixtures mocking Prisma operations

### Testing Strategy

**Test Categories:**

- Unit tests (70%): Base repository interface and implementation testing
- Integration tests (25%): Database module and unit of work testing
- Migration verification tests (5%): Ensure identical behavior after migration

**Testing Focus Areas:**

- Generic repository CRUD operations
- Mapping between domain and persistence models
- Transaction management and rollback scenarios
- Repository factory creation and management
- Error handling and edge cases

**Performance Testing:**

- Database query performance with new abstraction layer
- Transaction throughput with unit of work pattern
- Memory usage with repository factory management
- Connection pool efficiency with shared infrastructure

## Testing

### Testing Standards

**Framework and Location:**

- Jest 29.7.0 for backend testing
- Co-locate `*.spec.ts` files with source files
- Use ~/path alias in test imports

**Testing Patterns:**

- TDD approach: RED-GREEN-REFACTOR cycle
- AAA pattern: Arrange-Act-Assert structure
- 90%+ coverage through comprehensive unit tests
- Interface contract testing for repository abstractions
- Integration testing for infrastructure components

**Test Categories:**

- Unit tests (70%): Repository interfaces, base implementations, factory patterns
- Integration tests (25%): Database connectivity, transaction management, repository operations
- Migration verification tests (5%): Ensure existing functionality preservation

### Infrastructure Foundation Testing

**Repository Pattern Testing:**

- Generic interface contract validation
- Base implementation behavior verification
- Mapping function correctness and edge cases
- Error handling and exception scenarios

**Transaction Management Testing:**

- Unit of work pattern transaction boundaries
- Commit and rollback scenario testing
- Nested transaction handling
- Concurrent operation testing

**Factory Pattern Testing:**

- Repository registration and discovery
- Dynamic repository creation
- Dependency injection integration
- Lifecycle management verification

## Change Log

| Date       | Version | Description                                                                  | Author                  |
| ---------- | ------- | ---------------------------------------------------------------------------- | ----------------------- |
| 2025-09-02 | 1.0     | Initial story creation for Infrastructure Foundation and Repository Patterns | Claude (PM & Architect) |

## Dev Agent Record

_This section will be populated by the development agent during implementation_

### Agent Model Used

_To be filled during implementation_

### Debug Log References

_To be filled during implementation_

### Completion Notes List

_To be filled during implementation_

### File List

**Files to be Created:**

Shared Domain Layer:

- `apps/backend/src/shared/domain/repositories/BaseRepository.interface.ts`
- `apps/backend/src/shared/domain/repositories/index.ts`

Shared Infrastructure Layer:

- `apps/backend/src/shared/infrastructure/database/Database.module.ts`
- `apps/backend/src/shared/infrastructure/database/Prisma.service.ts`
- `apps/backend/src/shared/infrastructure/database/UnitOfWork.service.ts`
- `apps/backend/src/shared/infrastructure/database/index.ts`
- `apps/backend/src/shared/infrastructure/repositories/BaseRepository.abstract.ts`
- `apps/backend/src/shared/infrastructure/repositories/RepositoryFactory.service.ts`
- `apps/backend/src/shared/infrastructure/repositories/index.ts`

Test Files:

- `apps/backend/src/shared/domain/repositories/BaseRepository.interface.spec.ts`
- `apps/backend/src/shared/infrastructure/repositories/BaseRepository.abstract.spec.ts`
- `apps/backend/src/shared/infrastructure/database/UnitOfWork.service.spec.ts`
- `apps/backend/src/shared/infrastructure/repositories/RepositoryFactory.service.spec.ts`

**Files to be Modified:**

- `apps/backend/src/app.module.ts` - Import DatabaseModule instead of PrismaModule
- `apps/backend/src/auth/Auth.module.ts` - Update to use shared database infrastructure
- `apps/backend/src/auth/infrastructure/repositories/PrismaAuthUser.repository.ts` - Extend
  BaseRepository
- `apps/backend/src/users/Users.module.ts` - Update Prisma imports to use shared location

**Files to be Moved:**

- `apps/backend/src/prisma/prisma.service.ts` →
  `apps/backend/src/shared/infrastructure/database/Prisma.service.ts`
- `apps/backend/src/prisma/prisma.module.ts` →
  `apps/backend/src/shared/infrastructure/database/Prisma.module.ts`

**Files to be Deleted:**

- `apps/backend/src/prisma/` (entire directory after successful migration)
- `apps/backend/src/prisma/index.ts`

## QA Results

_This section will be populated by the QA agent during review_

### Review Date

_To be filled during review_

### Reviewed By

_To be filled during review_

### Code Quality Assessment

_To be filled during review_

### Refactoring Performed

_To be filled during review_

### Compliance Check

_To be filled during review_

### Requirements Traceability

_To be filled during review_

### Recommended Status

_To be filled during review_
